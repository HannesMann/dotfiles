From 566042f7f072927f66c07f033f5e55b399ed3196 Mon Sep 17 00:00:00 2001
From: Hannes Mann <hannesmann2000@gmail.com>
Date: Wed, 13 Dec 2023 04:42:44 +0100
Subject: [PATCH 1/4] Resize X11 clients at 144 Hz

---
 src/core/renderloop.cpp                       |  2 +-
 src/libkwineffects/kwinoffscreenquickview.cpp |  2 +-
 src/window.cpp                                |  2 +-
 src/x11window.cpp                             | 13 +++++++++++--
 src/x11window.h                               |  1 +
 5 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/core/renderloop.cpp b/src/core/renderloop.cpp
index 1fd3a0ba19..225ba6fc78 100644
--- a/src/core/renderloop.cpp
+++ b/src/core/renderloop.cpp
@@ -32,7 +32,7 @@ RenderLoopPrivate::RenderLoopPrivate(RenderLoop *q)
     compositeTimer.setTimerType(Qt::PreciseTimer);
     QObject::connect(&compositeTimer, &QTimer::timeout, q, [this]() {
         dispatch();
-    });
+    }, Qt::DirectConnection);
 }
 
 void RenderLoopPrivate::scheduleRepaint()
diff --git a/src/libkwineffects/kwinoffscreenquickview.cpp b/src/libkwineffects/kwinoffscreenquickview.cpp
index 76b2c525bc..35e7672ae3 100644
--- a/src/libkwineffects/kwinoffscreenquickview.cpp
+++ b/src/libkwineffects/kwinoffscreenquickview.cpp
@@ -195,7 +195,7 @@ OffscreenQuickView::OffscreenQuickView(QObject *parent, QWindow *renderWindow, E
 
     d->m_repaintTimer = std::make_unique<QTimer>();
     d->m_repaintTimer->setSingleShot(true);
-    d->m_repaintTimer->setInterval(10);
+    d->m_repaintTimer->setInterval(6);
 
     connect(d->m_repaintTimer.get(), &QTimer::timeout, this, &OffscreenQuickView::update);
     connect(d->m_renderControl.get(), &QQuickRenderControl::renderRequested, this, &OffscreenQuickView::handleRenderRequested);
diff --git a/src/window.cpp b/src/window.cpp
index 1cb311fa7c..ed7aab565e 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -4583,7 +4583,7 @@ void Window::unrefOffscreenRendering()
 void Window::maybeSendFrameCallback()
 {
     if (m_surface && !m_windowItem->isVisible()) {
-        m_surface->frameRendered(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
+        m_surface->frameRendered(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now().time_since_epoch()).count());
         // update refresh rate, it might have changed
         m_offscreenFramecallbackTimer.start(1'000'000 / output()->refreshRate());
     }
diff --git a/src/x11window.cpp b/src/x11window.cpp
index 3e3074f95b..cef06678f4 100644
--- a/src/x11window.cpp
+++ b/src/x11window.cpp
@@ -54,6 +54,7 @@
 // c++
 #include <cmath>
 #include <csignal>
+#include <chrono>
 
 // Put all externs before the namespace statement to allow the linker
 // to resolve them properly
@@ -4713,18 +4714,26 @@ void X11Window::doInteractiveResizeSync(const QRectF &rect)
         m_syncRequest.timeout = new QTimer(this);
         connect(m_syncRequest.timeout, &QTimer::timeout, this, &X11Window::handleSyncTimeout);
         m_syncRequest.timeout->setSingleShot(true);
+        m_syncRequest.timeout->setTimerType(Qt::PreciseTimer);
     }
 
     if (m_syncRequest.counter != XCB_NONE) {
         m_syncRequest.timeout->start(250);
         sendSyncRequest();
     } else {
-        // For clients not supporting the XSYNC protocol, we limit the resizes to 30Hz
+        // For clients not supporting the XSYNC protocol, we limit the resizes to 144Hz
         // to take pointless load from X11 and the client, the mouse is still moved at
         // full speed and no human can control faster resizes anyway.
         m_syncRequest.isPending = true;
         m_syncRequest.interactiveResize = true;
-        m_syncRequest.timeout->start(33);
+        // long currentTime = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();
+        // double diff = (currentTime * 0.000001) - (m_syncRequest.lastSyntheticResize * 0.000001);
+        // double waitTime = (1000.0 / 144.0) - diff;
+        // if (waitTime < 5) {
+        //    waitTime = 5;
+        // }
+        m_syncRequest.timeout->start(6);
+        // m_syncRequest.lastSyntheticResize = currentTime;
     }
 
     const QRectF moveResizeClientGeometry = frameRectToClientRect(moveResizeGeometry());
diff --git a/src/x11window.h b/src/x11window.h
index 635abb163c..d9dc195d12 100644
--- a/src/x11window.h
+++ b/src/x11window.h
@@ -302,6 +302,7 @@ public:
         QTimer *timeout, *failsafeTimeout;
         bool isPending;
         bool interactiveResize;
+        long lastSyntheticResize = 0;
     };
     const SyncRequest &syncRequest() const
     {
-- 
2.43.0

