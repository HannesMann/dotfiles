From 70cea232419d2377717b5a2ad4213faa7e987ffd Mon Sep 17 00:00:00 2001
From: Hannes Mann <hannesmann2000@gmail.com>
Date: Wed, 6 Mar 2024 02:17:44 +0100
Subject: [PATCH 2/4] obs-ffmpeg: AMF encoder on Linux with texture encoding

---
 libobs/obs-encoder.c                          |   4 +-
 libobs/obs-encoder.h                          |   2 +
 libobs/obs-internal.h                         |   3 +
 libobs/obs-video-gpu-encode.c                 |   2 +-
 plugins/obs-ffmpeg/CMakeLists.txt             |   7 +-
 plugins/obs-ffmpeg/cmake/dependencies.cmake   |   5 +-
 plugins/obs-ffmpeg/cmake/legacy.cmake         |   6 +-
 .../obs-ffmpeg/obs-amf-test/CMakeLists.txt    |  10 +-
 .../obs-amf-test/cmake/legacy.cmake           |  10 +-
 .../obs-amf-test/obs-amf-test-linux.cpp       | 140 +++
 plugins/obs-ffmpeg/obs-ffmpeg.c               |   6 +-
 plugins/obs-ffmpeg/texture-amf-opts.hpp       |   2 +-
 plugins/obs-ffmpeg/texture-amf.cpp            | 997 +++++++++++++++++-
 13 files changed, 1158 insertions(+), 36 deletions(-)
 create mode 100644 plugins/obs-ffmpeg/obs-amf-test/obs-amf-test-linux.cpp

diff --git a/libobs/obs-encoder.c b/libobs/obs-encoder.c
index 43361e56b..c084f684d 100644
--- a/libobs/obs-encoder.c
+++ b/libobs/obs-encoder.c
@@ -165,7 +165,7 @@ static inline void get_audio_info(const struct obs_encoder *encoder,
 		encoder->info.get_audio_info(encoder->context.data, info);
 }
 
-static inline void get_video_info(struct obs_encoder *encoder,
+void obs_encoder_get_video_info(struct obs_encoder *encoder,
 				  struct video_scale_info *info)
 {
 	const struct video_output_info *voi;
@@ -313,7 +313,7 @@ static void add_connection(struct obs_encoder *encoder)
 				     &audio_info, receive_audio, encoder);
 	} else {
 		struct video_scale_info info = {0};
-		get_video_info(encoder, &info);
+		obs_encoder_get_video_info(encoder, &info);
 
 		if (gpu_encode_available(encoder)) {
 			start_gpu_encode(encoder);
diff --git a/libobs/obs-encoder.h b/libobs/obs-encoder.h
index 26d35a872..d28ed9001 100644
--- a/libobs/obs-encoder.h
+++ b/libobs/obs-encoder.h
@@ -127,6 +127,8 @@ struct gs_texture;
 
 /** Encoder input texture */
 struct encoder_texture {
+	/** Texture format and size */
+	struct video_scale_info info;
 	/** Shared texture handle, only set on Windows */
 	uint32_t handle;
 	/** Textures, length determined by format */
diff --git a/libobs/obs-internal.h b/libobs/obs-internal.h
index 0fc114b07..2c6ddbc9d 100644
--- a/libobs/obs-internal.h
+++ b/libobs/obs-internal.h
@@ -1307,6 +1307,9 @@ extern struct obs_encoder_info *find_encoder(const char *id);
 extern bool obs_encoder_initialize(obs_encoder_t *encoder);
 extern void obs_encoder_shutdown(obs_encoder_t *encoder);
 
+extern void obs_encoder_get_video_info(struct obs_encoder *encoder,
+				       struct video_scale_info *info);
+
 extern void obs_encoder_start(obs_encoder_t *encoder,
 			      void (*new_packet)(void *param,
 						 struct encoder_packet *packet),
diff --git a/libobs/obs-video-gpu-encode.c b/libobs/obs-video-gpu-encode.c
index 4edfb2c53..8132128d3 100644
--- a/libobs/obs-video-gpu-encode.c
+++ b/libobs/obs-video-gpu-encode.c
@@ -137,7 +137,7 @@ static void *gpu_encode_thread(void *data)
 			profile_start(gpu_encode_frame_name);
 			if (encoder->info.encode_texture2) {
 				struct encoder_texture tex = {0};
-
+				obs_encoder_get_video_info(encoder, &tex.info);
 				tex.handle = tf.handle;
 				tex.tex[0] = tf.tex;
 				tex.tex[1] = tf.tex_uv;
diff --git a/plugins/obs-ffmpeg/CMakeLists.txt b/plugins/obs-ffmpeg/CMakeLists.txt
index 77c5ad8e4..fd140631a 100644
--- a/plugins/obs-ffmpeg/CMakeLists.txt
+++ b/plugins/obs-ffmpeg/CMakeLists.txt
@@ -26,8 +26,8 @@ target_sources(
           $<$<PLATFORM_ID:Windows>:obs-nvenc-helpers.c>
           $<$<PLATFORM_ID:Windows>:obs-nvenc.c>
           $<$<PLATFORM_ID:Windows>:obs-nvenc.h>
-          $<$<PLATFORM_ID:Windows>:texture-amf-opts.hpp>
-          $<$<PLATFORM_ID:Windows>:texture-amf.cpp>
+          texture-amf-opts.hpp>
+          texture-amf.cpp>
           obs-ffmpeg-audio-encoders.c
           obs-ffmpeg-av1.c
           obs-ffmpeg-compat.h
@@ -60,12 +60,13 @@ target_link_libraries(
           FFmpeg::swresample
           $<$<PLATFORM_ID:Windows>:OBS::obs-nvenc-version>
           $<$<PLATFORM_ID:Windows>:OBS::w32-pthreads>
-          $<$<PLATFORM_ID:Windows>:AMF::AMF>
+          AMF::AMF>
           $<$<PLATFORM_ID:Windows>:FFnvcodec::FFnvcodec>
           $<$<PLATFORM_ID:Windows>:ws2_32>
           $<$<PLATFORM_ID:Linux,FreeBSD,OpenBSD>:Libva::va>
           $<$<PLATFORM_ID:Linux,FreeBSD,OpenBSD>:Libva::drm>
           $<$<PLATFORM_ID:Linux,FreeBSD,OpenBSD>:Libpci::pci>
+          $<$<PLATFORM_ID:Linux,FreeBSD,OpenBSD>:Vulkan::Vulkan>
           $<$<BOOL:${ENABLE_NEW_MPEGTS_OUTPUT}>:Librist::Librist>
           $<$<BOOL:${ENABLE_NEW_MPEGTS_OUTPUT}>:Libsrt::Libsrt>)
 
diff --git a/plugins/obs-ffmpeg/cmake/dependencies.cmake b/plugins/obs-ffmpeg/cmake/dependencies.cmake
index 5a52c751a..4d73a40d7 100644
--- a/plugins/obs-ffmpeg/cmake/dependencies.cmake
+++ b/plugins/obs-ffmpeg/cmake/dependencies.cmake
@@ -24,8 +24,9 @@ if(NOT TARGET OBS::opts-parser)
   add_subdirectory("${CMAKE_SOURCE_DIR}/deps/opts-parser" "${CMAKE_BINARY_DIR}/deps/opts-parser")
 endif()
 
+find_package(AMF 1.4.29 REQUIRED)
+
 if(OS_WINDOWS)
-  find_package(AMF 1.4.29 REQUIRED)
   find_package(FFnvcodec 12 REQUIRED)
 
   add_library(obs-nvenc-version INTERFACE)
@@ -41,6 +42,8 @@ elseif(
   OR OS_OPENBSD)
   find_package(Libva REQUIRED)
   find_package(Libpci REQUIRED)
+  find_package(Vulkan REQUIRED)
+  add_subdirectory(obs-amf-test)
 endif()
 
 if(ENABLE_NEW_MPEGTS_OUTPUT)
diff --git a/plugins/obs-ffmpeg/cmake/legacy.cmake b/plugins/obs-ffmpeg/cmake/legacy.cmake
index b7d665c00..c7ba8461c 100644
--- a/plugins/obs-ffmpeg/cmake/legacy.cmake
+++ b/plugins/obs-ffmpeg/cmake/legacy.cmake
@@ -108,11 +108,13 @@ if(OS_WINDOWS)
             obs-ffmpeg.rc)
 
 elseif(OS_POSIX AND NOT OS_MACOS)
+  add_subdirectory(obs-amf-test)
   find_package(Libva REQUIRED)
   find_package(Libpci REQUIRED)
   find_package(Libdrm REQUIRED)
-  target_sources(obs-ffmpeg PRIVATE obs-ffmpeg-vaapi.c vaapi-utils.c vaapi-utils.h)
-  target_link_libraries(obs-ffmpeg PRIVATE Libva::va Libva::drm LIBPCI::LIBPCI Libdrm::Libdrm)
+  find_package(Vulkan REQUIRED)
+  target_sources(obs-ffmpeg PRIVATE obs-ffmpeg-vaapi.c vaapi-utils.c vaapi-utils.h texture-amf.cpp)
+  target_link_libraries(obs-ffmpeg PRIVATE Libva::va Libva::drm LIBPCI::LIBPCI Vulkan::Vulkan)
 endif()
 
 setup_plugin_target(obs-ffmpeg)
diff --git a/plugins/obs-ffmpeg/obs-amf-test/CMakeLists.txt b/plugins/obs-ffmpeg/obs-amf-test/CMakeLists.txt
index 6221c69df..93f1ee7d5 100644
--- a/plugins/obs-ffmpeg/obs-amf-test/CMakeLists.txt
+++ b/plugins/obs-ffmpeg/obs-amf-test/CMakeLists.txt
@@ -7,8 +7,14 @@ find_package(AMF 1.4.29 REQUIRED)
 add_executable(obs-amf-test)
 add_executable(OBS::amf-test ALIAS obs-amf-test)
 
-target_sources(obs-amf-test PRIVATE obs-amf-test.cpp)
-target_link_libraries(obs-amf-test PRIVATE OBS::COMutils AMF::AMF d3d11 dxgi dxguid)
+if(OS_WINDOWS)
+  target_sources(obs-amf-test PRIVATE obs-amf-test.cpp)
+  target_link_libraries(obs-amf-test PRIVATE OBS::COMutils AMF::AMF d3d11 dxgi dxguid)
+elseif(OS_POSIX AND NOT OS_MACOS)
+  find_package(Vulkan REQUIRED)
+  target_sources(obs-amf-test PRIVATE obs-amf-test-linux.cpp)
+  target_link_libraries(obs-amf-test dl Vulkan::Vulkan AMF::AMF)
+endif()
 
 # cmake-format: off
 set_target_properties_obs(obs-amf-test PROPERTIES FOLDER plugins/obs-ffmpeg)
diff --git a/plugins/obs-ffmpeg/obs-amf-test/cmake/legacy.cmake b/plugins/obs-ffmpeg/obs-amf-test/cmake/legacy.cmake
index e00cef1cf..07cf1e0fc 100644
--- a/plugins/obs-ffmpeg/obs-amf-test/cmake/legacy.cmake
+++ b/plugins/obs-ffmpeg/obs-amf-test/cmake/legacy.cmake
@@ -6,8 +6,14 @@ find_package(AMF 1.4.29 REQUIRED)
 
 target_include_directories(obs-amf-test PRIVATE ${CMAKE_SOURCE_DIR}/libobs)
 
-target_sources(obs-amf-test PRIVATE obs-amf-test.cpp)
-target_link_libraries(obs-amf-test d3d11 dxgi dxguid AMF::AMF)
+if(OS_WINDOWS)
+  target_sources(obs-amf-test PRIVATE obs-amf-test.cpp)
+  target_link_libraries(obs-amf-test d3d11 dxgi dxguid AMF::AMF)
+elseif(OS_POSIX AND NOT OS_MACOS)
+  find_package(Vulkan REQUIRED)
+  target_sources(obs-amf-test PRIVATE obs-amf-test-linux.cpp)
+  target_link_libraries(obs-amf-test dl Vulkan::Vulkan AMF::AMF)
+endif()
 
 set_target_properties(obs-amf-test PROPERTIES FOLDER "plugins/obs-ffmpeg")
 
diff --git a/plugins/obs-ffmpeg/obs-amf-test/obs-amf-test-linux.cpp b/plugins/obs-ffmpeg/obs-amf-test/obs-amf-test-linux.cpp
new file mode 100644
index 000000000..db437d851
--- /dev/null
+++ b/plugins/obs-ffmpeg/obs-amf-test/obs-amf-test-linux.cpp
@@ -0,0 +1,140 @@
+#include <AMF/core/Factory.h>
+#include <AMF/core/Trace.h>
+#include <AMF/components/VideoEncoderVCE.h>
+#include <AMF/components/VideoEncoderHEVC.h>
+#include <AMF/components/VideoEncoderAV1.h>
+
+#include <dlfcn.h>
+#include <vulkan/vulkan.hpp>
+
+#include <string>
+#include <map>
+
+using namespace amf;
+
+struct adapter_caps {
+	bool is_amd = false;
+	bool supports_avc = false;
+	bool supports_hevc = false;
+	bool supports_av1 = false;
+};
+
+static AMFFactory *amf_factory = nullptr;
+static std::map<uint32_t, adapter_caps> adapter_info;
+
+static bool has_encoder(AMFContextPtr &amf_context, const wchar_t *encoder_name)
+{
+	AMFComponentPtr encoder;
+	AMF_RESULT res = amf_factory->CreateComponent(amf_context, encoder_name,
+						      &encoder);
+	return res == AMF_OK;
+}
+
+static bool get_adapter_caps(uint32_t adapter_idx)
+{
+	if (adapter_idx)
+		return false;
+
+	adapter_caps &caps = adapter_info[adapter_idx];
+
+	AMF_RESULT res;
+	AMFContextPtr amf_context;
+	res = amf_factory->CreateContext(&amf_context);
+	if (res != AMF_OK)
+		return true;
+
+	AMFContext1 *context1 = NULL;
+	res = amf_context->QueryInterface(AMFContext1::IID(),
+					  (void **)&context1);
+	if (res != AMF_OK)
+		return false;
+	res = context1->InitVulkan(nullptr);
+	context1->Release();
+	if (res != AMF_OK)
+		return false;
+
+	caps.is_amd = true;
+	caps.supports_avc = has_encoder(amf_context, AMFVideoEncoderVCE_AVC);
+	caps.supports_hevc = has_encoder(amf_context, AMFVideoEncoder_HEVC);
+	caps.supports_av1 = has_encoder(amf_context, AMFVideoEncoder_AV1);
+
+	return true;
+}
+
+int main(void)
+try {
+	AMF_RESULT res;
+	VkResult vkres;
+
+	VkApplicationInfo app_info = {};
+	app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
+	app_info.pApplicationName = "obs-amf-test";
+	app_info.apiVersion = VK_API_VERSION_1_2;
+
+	VkInstanceCreateInfo info = {};
+	info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
+	info.pApplicationInfo = &app_info;
+
+	VkInstance instance;
+	vkres = vkCreateInstance(&info, nullptr, &instance);
+	if (vkres != VK_SUCCESS)
+		throw "Failed to initialize Vulkan";
+
+	uint32_t device_count;
+	vkres = vkEnumeratePhysicalDevices(instance, &device_count, nullptr);
+	if (vkres != VK_SUCCESS || !device_count)
+		throw "Failed to enumerate Vulkan devices";
+
+	VkPhysicalDevice *devices = new VkPhysicalDevice[device_count];
+	vkres = vkEnumeratePhysicalDevices(instance, &device_count, devices);
+	if (vkres != VK_SUCCESS)
+		throw "Failed to enumerate Vulkan devices";
+
+	VkPhysicalDeviceDriverProperties driver_props = {};
+	driver_props.sType =
+		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
+	VkPhysicalDeviceProperties2 device_props = {};
+	device_props.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
+	device_props.pNext = &driver_props;
+	vkGetPhysicalDeviceProperties2(devices[0], &device_props);
+
+	if (strcmp(driver_props.driverName, "AMD proprietary driver"))
+		throw "Not running AMD proprietary driver";
+
+	vkDestroyInstance(instance, nullptr);
+
+	/* --------------------------------------------------------- */
+	/* try initializing amf, I guess                             */
+
+	void *amf_module = dlopen(AMF_DLL_NAMEA, RTLD_LAZY);
+	if (!amf_module)
+		throw "Failed to load AMF lib";
+
+	auto init = (AMFInit_Fn)dlsym(amf_module, AMF_INIT_FUNCTION_NAME);
+	if (!init)
+		throw "Failed to get init func";
+
+	res = init(AMF_FULL_VERSION, &amf_factory);
+	if (res != AMF_OK)
+		throw "AMFInit failed";
+
+	uint32_t idx = 0;
+	while (get_adapter_caps(idx++))
+		;
+
+	for (auto &[idx, caps] : adapter_info) {
+		printf("[%u]\n", idx);
+		printf("is_amd=%s\n", caps.is_amd ? "true" : "false");
+		printf("supports_avc=%s\n",
+		       caps.supports_avc ? "true" : "false");
+		printf("supports_hevc=%s\n",
+		       caps.supports_hevc ? "true" : "false");
+		printf("supports_av1=%s\n",
+		       caps.supports_av1 ? "true" : "false");
+	}
+
+	return 0;
+} catch (const char *text) {
+	printf("[error]\nstring=%s\n", text);
+	return 0;
+}
diff --git a/plugins/obs-ffmpeg/obs-ffmpeg.c b/plugins/obs-ffmpeg/obs-ffmpeg.c
index d58f00701..57011c0ba 100644
--- a/plugins/obs-ffmpeg/obs-ffmpeg.c
+++ b/plugins/obs-ffmpeg/obs-ffmpeg.c
@@ -342,9 +342,9 @@ static bool hevc_vaapi_supported(void)
 #ifdef _WIN32
 extern void obs_nvenc_load(bool h264, bool hevc, bool av1);
 extern void obs_nvenc_unload(void);
+#endif
 extern void amf_load(void);
 extern void amf_unload(void);
-#endif
 
 #if ENABLE_FFMPEG_LOGGING
 extern void obs_ffmpeg_load_logging(void);
@@ -395,9 +395,7 @@ bool obs_module_load(void)
 #endif
 	}
 
-#ifdef _WIN32
 	amf_load();
-#endif
 
 #ifdef LIBAVUTIL_VAAPI_AVAILABLE
 	const char *libva_env = getenv("LIBVA_DRIVER_NAME");
@@ -446,8 +444,8 @@ void obs_module_unload(void)
 	obs_ffmpeg_unload_logging();
 #endif
 
-#ifdef _WIN32
 	amf_unload();
+#ifdef _WIN32
 	obs_nvenc_unload();
 #endif
 }
diff --git a/plugins/obs-ffmpeg/texture-amf-opts.hpp b/plugins/obs-ffmpeg/texture-amf-opts.hpp
index b1c37d200..d28e3f77e 100644
--- a/plugins/obs-ffmpeg/texture-amf-opts.hpp
+++ b/plugins/obs-ffmpeg/texture-amf-opts.hpp
@@ -321,7 +321,7 @@ static void amf_apply_opt(amf_base *enc, obs_option *opt)
 			val = atoi(opt->value);
 		}
 
-		os_utf8_to_wcs(opt->name, 0, wname, _countof(wname));
+		os_utf8_to_wcs(opt->name, 0, wname, amf_countof(wname));
 		if (is_bool) {
 			bool bool_val = (bool)val;
 			set_amf_property(enc, wname, bool_val);
diff --git a/plugins/obs-ffmpeg/texture-amf.cpp b/plugins/obs-ffmpeg/texture-amf.cpp
index 7a698931b..b1e07cfcb 100644
--- a/plugins/obs-ffmpeg/texture-amf.cpp
+++ b/plugins/obs-ffmpeg/texture-amf.cpp
@@ -11,6 +11,7 @@
 #include <mutex>
 #include <deque>
 #include <map>
+#include <inttypes.h>
 
 #include <AMF/components/VideoEncoderHEVC.h>
 #include <AMF/components/VideoEncoderVCE.h>
@@ -18,6 +19,7 @@
 #include <AMF/core/Factory.h>
 #include <AMF/core/Trace.h>
 
+#ifdef _WIN32
 #include <dxgi.h>
 #include <d3d11.h>
 #include <d3d11_1.h>
@@ -25,6 +27,17 @@
 #include <util/windows/device-enum.h>
 #include <util/windows/HRError.hpp>
 #include <util/windows/ComPtr.hpp>
+#endif
+
+#ifdef __linux
+#include <algorithm>
+#include <GL/glcorearb.h>
+#include <GL/glext.h>
+#include <EGL/egl.h>
+#include <vulkan/vulkan.h>
+#include <AMF/core/VulkanAMF.h>
+#endif
+
 #include <util/platform.h>
 #include <util/util.hpp>
 #include <util/pipe.h>
@@ -53,12 +66,89 @@ struct amf_error {
 	}
 };
 
+#define VK_CHECK(f)                                                      \
+	{                                                                \
+		VkResult res = (f);                                      \
+		if (res != VK_SUCCESS) {                                 \
+			blog(LOG_ERROR, "Vulkan error: " __FILE__ ":%d", \
+			     __LINE__);                                  \
+			throw "Vulkan error";                            \
+		}                                                        \
+	}
+
+static VkFormat to_vk_format(AMF_SURFACE_FORMAT fmt)
+{
+	switch (fmt) {
+	case AMF_SURFACE_NV12:
+		return VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
+	case AMF_SURFACE_P010:
+		return VK_FORMAT_G16_B16R16_2PLANE_420_UNORM;
+	default:
+		throw "Unsupported AMF_SURFACE_FORMAT";
+	}
+}
+
+static VkFormat to_vk_format(enum gs_color_format fmt)
+{
+	switch (fmt) {
+	case GS_R8:
+		return VK_FORMAT_R8_UNORM;
+	case GS_R16:
+		return VK_FORMAT_R16_UNORM;
+	case GS_R8G8:
+		return VK_FORMAT_R8G8_UNORM;
+	case GS_RG16:
+		return VK_FORMAT_R16G16_UNORM;
+	default:
+		throw "Unsupported gs_color_format";
+	}
+}
+
+static GLenum to_gl_format(enum gs_color_format fmt)
+{
+	switch (fmt) {
+	case GS_R8:
+		return GL_R8;
+	case GS_R16:
+		return GL_R16;
+	case GS_R8G8:
+		return GL_RG8;
+	case GS_RG16:
+		return GL_RG16;
+	default:
+		throw "Unsupported gs_color_format";
+	}
+}
+
 struct handle_tex {
 	uint32_t handle;
+#ifdef _WIN32
 	ComPtr<ID3D11Texture2D> tex;
 	ComPtr<IDXGIKeyedMutex> km;
+#else
+	AMFVulkanSurface *surfaceVk = nullptr;
+#endif
 };
 
+#ifdef __linux
+struct gl_tex {
+	GLuint glsem = 0;
+	VkSemaphore sem = VK_NULL_HANDLE;
+	GLuint glCopySem = 0;
+	VkSemaphore copySem = VK_NULL_HANDLE;
+	VkFence copyFence = VK_NULL_HANDLE;
+	struct {
+		uint32_t width = 0;
+		uint32_t height = 0;
+		VkImage image = VK_NULL_HANDLE;
+		VkDeviceMemory memory = VK_NULL_HANDLE;
+		GLuint glmem = 0;
+		GLuint gltex = 0;
+		GLuint fbo = 0;
+	} planes[2];
+};
+#endif
+
 struct adapter_caps {
 	bool is_amd = false;
 	bool supports_avc = false;
@@ -72,7 +162,7 @@ static std::map<uint32_t, adapter_caps> caps;
 static bool h264_supported = false;
 static AMFFactory *amf_factory = nullptr;
 static AMFTrace *amf_trace = nullptr;
-static HMODULE amf_module = nullptr;
+static void *amf_module = nullptr;
 static uint64_t amf_version = 0;
 
 /* ========================================================================= */
@@ -91,6 +181,7 @@ struct amf_base {
 	bool fallback;
 
 	AMFContextPtr amf_context;
+	AMFContext1Ptr amf_context1;
 	AMFComponentPtr amf_encoder;
 	AMFBufferPtr packet_data;
 	AMFRate amf_frame_rate;
@@ -124,9 +215,14 @@ struct amf_base {
 	virtual void init() = 0;
 };
 
-using d3dtex_t = ComPtr<ID3D11Texture2D>;
 using buf_t = std::vector<uint8_t>;
 
+#ifdef _WIN32
+using d3dtex_t = ComPtr<ID3D11Texture2D>;
+#else
+using d3dtex_t = handle_tex;
+#endif
+
 struct amf_texencode : amf_base, public AMFSurfaceObserver {
 	volatile bool destroying = false;
 
@@ -136,11 +232,92 @@ struct amf_texencode : amf_base, public AMFSurfaceObserver {
 	std::vector<d3dtex_t> available_textures;
 	std::unordered_map<AMFSurface *, d3dtex_t> active_textures;
 
+#ifdef _WIN32
 	ComPtr<ID3D11Device> device;
 	ComPtr<ID3D11DeviceContext> context;
+#else
+	std::unique_ptr<AMFVulkanDevice> vk;
+	VkQueue queue = VK_NULL_HANDLE;
+	VkCommandPool cmdpool = VK_NULL_HANDLE;
+	VkCommandBuffer cmdbuf = VK_NULL_HANDLE;
+	struct gl_tex gltex = {};
+	std::unordered_map<gs_texture *, GLuint> read_fbos;
+
+	PFN_vkGetMemoryFdKHR vkGetMemoryFdKHR;
+	PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHR;
+	PFNGLGETERRORPROC glGetError;
+	PFNGLCREATEMEMORYOBJECTSEXTPROC glCreateMemoryObjectsEXT;
+	PFNGLDELETEMEMORYOBJECTSEXTPROC glDeleteMemoryObjectsEXT;
+	PFNGLIMPORTMEMORYFDEXTPROC glImportMemoryFdEXT;
+	PFNGLISMEMORYOBJECTEXTPROC glIsMemoryObjectEXT;
+	PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glMemoryObjectParameterivEXT;
+	PFNGLGENTEXTURESPROC glGenTextures;
+	PFNGLDELETETEXTURESPROC glDeleteTextures;
+	PFNGLBINDTEXTUREPROC glBindTexture;
+	PFNGLTEXPARAMETERIPROC glTexParameteri;
+	PFNGLTEXSTORAGEMEM2DEXTPROC glTexStorageMem2DEXT;
+	PFNGLGENSEMAPHORESEXTPROC glGenSemaphoresEXT;
+	PFNGLDELETESEMAPHORESEXTPROC glDeleteSemaphoresEXT;
+	PFNGLIMPORTSEMAPHOREFDEXTPROC glImportSemaphoreFdEXT;
+	PFNGLISSEMAPHOREEXTPROC glIsSemaphoreEXT;
+	PFNGLWAITSEMAPHOREEXTPROC glWaitSemaphoreEXT;
+	PFNGLSIGNALSEMAPHOREEXTPROC glSignalSemaphoreEXT;
+	PFNGLGENFRAMEBUFFERSPROC glGenFramebuffers;
+	PFNGLDELETEFRAMEBUFFERSPROC glDeleteFramebuffers;
+	PFNGLBINDFRAMEBUFFERPROC glBindFramebuffer;
+	PFNGLFRAMEBUFFERTEXTURE2DPROC glFramebufferTexture2D;
+	PFNGLBLITFRAMEBUFFERPROC glBlitFramebuffer;
+#endif
 
 	inline amf_texencode() : amf_base(false) {}
-	~amf_texencode() { os_atomic_set_bool(&destroying, true); }
+	~amf_texencode()
+	{
+		os_atomic_set_bool(&destroying, true);
+#ifdef __linux
+		if (!vk)
+			return;
+
+		vkDeviceWaitIdle(vk->hDevice);
+		vkFreeCommandBuffers(vk->hDevice, cmdpool, 1, &cmdbuf);
+		vkDestroyCommandPool(vk->hDevice, cmdpool, nullptr);
+
+		for (auto t : input_textures) {
+			vkFreeMemory(vk->hDevice, t.surfaceVk->hMemory,
+				     nullptr);
+			vkDestroyImage(vk->hDevice, t.surfaceVk->hImage,
+				       nullptr);
+			delete t.surfaceVk;
+		}
+
+		obs_enter_graphics();
+
+		for (int i = 0; i < 2; ++i) {
+			auto p = gltex.planes[i];
+			vkFreeMemory(vk->hDevice, p.memory, nullptr);
+			vkDestroyImage(vk->hDevice, p.image, nullptr);
+			this->glDeleteMemoryObjectsEXT(1, &p.glmem);
+			this->glDeleteTextures(1, &p.gltex);
+			this->glDeleteFramebuffers(1, &p.fbo);
+		}
+		vkDestroySemaphore(vk->hDevice, gltex.sem, nullptr);
+		vkDestroySemaphore(vk->hDevice, gltex.copySem, nullptr);
+		vkDestroyFence(vk->hDevice, gltex.copyFence, nullptr);
+		this->glDeleteSemaphoresEXT(1, &gltex.glsem);
+		this->glDeleteSemaphoresEXT(1, &gltex.glCopySem);
+
+		for (auto f : read_fbos)
+			this->glDeleteFramebuffers(1, &f.second);
+
+		obs_leave_graphics();
+
+		amf_encoder->Terminate();
+		amf_context1->Terminate();
+		amf_context->Terminate();
+
+		vkDestroyDevice(vk->hDevice, nullptr);
+		vkDestroyInstance(vk->hInstance, nullptr);
+#endif
+	}
 
 	void AMF_STD_CALL OnSurfaceDataRelease(amf::AMFSurface *surf) override
 	{
@@ -158,9 +335,187 @@ struct amf_texencode : amf_base, public AMFSurfaceObserver {
 
 	void init() override
 	{
+#if defined(_WIN32)
 		AMF_RESULT res = amf_context->InitDX11(device, AMF_DX11_1);
 		if (res != AMF_OK)
 			throw amf_error("InitDX11 failed", res);
+#elif defined(__linux__)
+		vk = std::make_unique<AMFVulkanDevice>();
+		vk->cbSizeof = sizeof(AMFVulkanDevice);
+
+		std::vector<const char *> instance_extensions = {
+			VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
+			VK_KHR_SURFACE_EXTENSION_NAME,
+		};
+
+		std::vector<const char *> device_extensions = {
+			VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
+			VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
+			VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME,
+			VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME,
+		};
+
+		amf_size count = 0;
+		amf_context1->GetVulkanDeviceExtensions(&count, nullptr);
+		device_extensions.resize(device_extensions.size() + count);
+		amf_context1->GetVulkanDeviceExtensions(
+			&count,
+			&device_extensions[device_extensions.size() - count]);
+
+		VkApplicationInfo appInfo = {};
+		appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
+		appInfo.pApplicationName = "OBS";
+		appInfo.apiVersion = VK_API_VERSION_1_2;
+
+		VkInstanceCreateInfo instanceInfo = {};
+		instanceInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
+		instanceInfo.pApplicationInfo = &appInfo;
+		instanceInfo.enabledExtensionCount = instance_extensions.size();
+		instanceInfo.ppEnabledExtensionNames =
+			instance_extensions.data();
+		VK_CHECK(vkCreateInstance(&instanceInfo, nullptr,
+					  &vk->hInstance));
+
+		uint32_t deviceCount = 0;
+		VK_CHECK(vkEnumeratePhysicalDevices(vk->hInstance, &deviceCount,
+						    nullptr));
+		std::vector<VkPhysicalDevice> physicalDevices(deviceCount);
+		VK_CHECK(vkEnumeratePhysicalDevices(vk->hInstance, &deviceCount,
+						    physicalDevices.data()));
+		for (VkPhysicalDevice dev : physicalDevices) {
+			VkPhysicalDeviceDriverProperties driverProps = {};
+			driverProps.sType =
+				VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
+
+			VkPhysicalDeviceProperties2 props = {};
+			props.sType =
+				VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
+			props.pNext = &driverProps;
+			vkGetPhysicalDeviceProperties2(dev, &props);
+			if (driverProps.driverID ==
+			    VK_DRIVER_ID_AMD_PROPRIETARY) {
+				vk->hPhysicalDevice = dev;
+				break;
+			}
+		}
+		if (!vk->hPhysicalDevice) {
+			throw "Failed to find Vulkan device VK_DRIVER_ID_AMD_PROPRIETARY";
+		}
+
+		uint32_t deviceExtensionCount = 0;
+		VK_CHECK(vkEnumerateDeviceExtensionProperties(
+			vk->hPhysicalDevice, nullptr, &deviceExtensionCount,
+			nullptr));
+		std::vector<VkExtensionProperties> deviceExts(
+			deviceExtensionCount);
+		VK_CHECK(vkEnumerateDeviceExtensionProperties(
+			vk->hPhysicalDevice, nullptr, &deviceExtensionCount,
+			deviceExts.data()));
+		std::vector<const char *> deviceExtensions;
+		for (const char *name : device_extensions) {
+			auto it = std::find_if(
+				deviceExts.begin(), deviceExts.end(),
+				[name](VkExtensionProperties e) {
+					return strcmp(e.extensionName, name) ==
+					       0;
+				});
+			if (it != deviceExts.end()) {
+				deviceExtensions.push_back(name);
+			}
+		}
+
+		float queuePriority = 1.0;
+		std::vector<VkDeviceQueueCreateInfo> queueInfos;
+		uint32_t queueFamilyCount;
+		vkGetPhysicalDeviceQueueFamilyProperties(
+			vk->hPhysicalDevice, &queueFamilyCount, nullptr);
+		std::vector<VkQueueFamilyProperties> queueFamilyProperties(
+			queueFamilyCount);
+		vkGetPhysicalDeviceQueueFamilyProperties(
+			vk->hPhysicalDevice, &queueFamilyCount,
+			queueFamilyProperties.data());
+		for (uint32_t i = 0; i < queueFamilyProperties.size(); ++i) {
+			VkDeviceQueueCreateInfo queueInfo = {};
+			queueInfo.sType =
+				VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
+			queueInfo.queueFamilyIndex = i;
+			queueInfo.queueCount = 1;
+			queueInfo.pQueuePriorities = &queuePriority;
+			queueInfos.push_back(queueInfo);
+		}
+
+		VkDeviceCreateInfo deviceInfo = {};
+		deviceInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
+		deviceInfo.queueCreateInfoCount = queueInfos.size();
+		deviceInfo.pQueueCreateInfos = queueInfos.data();
+		deviceInfo.enabledExtensionCount = deviceExtensions.size();
+		deviceInfo.ppEnabledExtensionNames = deviceExtensions.data();
+		VK_CHECK(vkCreateDevice(vk->hPhysicalDevice, &deviceInfo,
+					nullptr, &vk->hDevice));
+
+		AMF_RESULT res = amf_context1->InitVulkan(vk.get());
+		if (res != AMF_OK)
+			throw amf_error("InitVulkan failed", res);
+
+		vkGetDeviceQueue(vk->hDevice, 0, 0, &queue);
+
+		VkCommandPoolCreateInfo cmdPoolInfo = {};
+		cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
+		cmdPoolInfo.queueFamilyIndex = 0;
+		cmdPoolInfo.flags =
+			VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
+		VK_CHECK(vkCreateCommandPool(vk->hDevice, &cmdPoolInfo, nullptr,
+					     &cmdpool));
+
+		VkCommandBufferAllocateInfo commandBufferInfo = {};
+		commandBufferInfo.sType =
+			VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
+		commandBufferInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+		commandBufferInfo.commandPool = cmdpool;
+		commandBufferInfo.commandBufferCount = 1;
+		VK_CHECK(vkAllocateCommandBuffers(vk->hDevice,
+						  &commandBufferInfo, &cmdbuf));
+
+#define GET_PROC_VK(x)                                 \
+	x = reinterpret_cast<decltype(x)>(             \
+		vkGetDeviceProcAddr(vk->hDevice, #x)); \
+	if (!x)                                        \
+		throw "Failed to resolve " #x;
+
+#define GET_PROC_GL(x)                                            \
+	x = reinterpret_cast<decltype(x)>(eglGetProcAddress(#x)); \
+	if (!x)                                                   \
+		throw "Failed to resolve " #x;
+
+		GET_PROC_VK(vkGetMemoryFdKHR);
+		GET_PROC_VK(vkGetSemaphoreFdKHR);
+		GET_PROC_GL(glGetError);
+		GET_PROC_GL(glCreateMemoryObjectsEXT);
+		GET_PROC_GL(glDeleteMemoryObjectsEXT);
+		GET_PROC_GL(glImportMemoryFdEXT);
+		GET_PROC_GL(glIsMemoryObjectEXT);
+		GET_PROC_GL(glMemoryObjectParameterivEXT);
+		GET_PROC_GL(glGenTextures);
+		GET_PROC_GL(glDeleteTextures);
+		GET_PROC_GL(glBindTexture);
+		GET_PROC_GL(glTexParameteri);
+		GET_PROC_GL(glTexStorageMem2DEXT);
+		GET_PROC_GL(glGenSemaphoresEXT);
+		GET_PROC_GL(glDeleteSemaphoresEXT);
+		GET_PROC_GL(glImportSemaphoreFdEXT);
+		GET_PROC_GL(glIsSemaphoreEXT);
+		GET_PROC_GL(glWaitSemaphoreEXT);
+		GET_PROC_GL(glSignalSemaphoreEXT);
+		GET_PROC_GL(glGenFramebuffers);
+		GET_PROC_GL(glDeleteFramebuffers);
+		GET_PROC_GL(glBindFramebuffer);
+		GET_PROC_GL(glFramebufferTexture2D);
+		GET_PROC_GL(glBlitFramebuffer);
+
+#undef GET_PROC_VK
+#undef GET_PROC_GL
+
+#endif
 	}
 };
 
@@ -190,9 +545,15 @@ struct amf_fallback : amf_base, public AMFSurfaceObserver {
 
 	void init() override
 	{
+#if defined(_WIN32)
 		AMF_RESULT res = amf_context->InitDX11(nullptr, AMF_DX11_1);
 		if (res != AMF_OK)
 			throw amf_error("InitDX11 failed", res);
+#elif defined(__linux__)
+		AMF_RESULT res = amf_context1->InitVulkan(nullptr);
+		if (res != AMF_OK)
+			throw amf_error("InitVulkan failed", res);
+#endif
 	}
 };
 
@@ -234,13 +595,18 @@ static void set_amf_property(amf_base *enc, const wchar_t *name, const T &value)
 	 : (enc->codec == amf_codec_type::HEVC)                         \
 		 ? AMF_VIDEO_ENCODER_HEVC_##name                        \
 		 : AMF_VIDEO_ENCODER_AV1_##name)
+#define get_opt_name_enum(name)                                              \
+	((enc->codec == amf_codec_type::AVC) ? (int)AMF_VIDEO_ENCODER_##name \
+	 : (enc->codec == amf_codec_type::HEVC)                         \
+		 ? (int)AMF_VIDEO_ENCODER_HEVC_##name                        \
+		 : (int)AMF_VIDEO_ENCODER_AV1_##name)
 #define set_opt(name, value) set_amf_property(enc, get_opt_name(name), value)
 #define get_opt(name, value) get_amf_property(enc, get_opt_name(name), value)
 #define set_avc_opt(name, value) set_avc_property(enc, name, value)
 #define set_hevc_opt(name, value) set_hevc_property(enc, name, value)
 #define set_av1_opt(name, value) set_av1_property(enc, name, value)
 #define set_enum_opt(name, value) \
-	set_amf_property(enc, get_opt_name(name), get_opt_name(name##_##value))
+	set_amf_property(enc, get_opt_name(name), get_opt_name_enum(name##_##value))
 #define set_avc_enum(name, value) \
 	set_avc_property(enc, name, AMF_VIDEO_ENCODER_##name##_##value)
 #define set_hevc_enum(name, value) \
@@ -251,6 +617,7 @@ static void set_amf_property(amf_base *enc, const wchar_t *name, const T &value)
 /* ------------------------------------------------------------------------- */
 /* Implementation                                                            */
 
+#ifdef _WIN32
 static HMODULE get_lib(const char *lib)
 {
 	HMODULE mod = GetModuleHandleA(lib);
@@ -397,6 +764,362 @@ static void get_tex_from_handle(amf_texencode *enc, uint32_t handle,
 	*km_out = km.Detach();
 	*tex_out = tex.Detach();
 }
+#else
+static uint32_t memoryTypeIndex(amf_texencode *enc,
+				VkMemoryPropertyFlags properties,
+				uint32_t typeBits)
+{
+	VkPhysicalDeviceMemoryProperties prop;
+	vkGetPhysicalDeviceMemoryProperties(enc->vk->hPhysicalDevice, &prop);
+	for (uint32_t i = 0; i < prop.memoryTypeCount; i++) {
+		if ((prop.memoryTypes[i].propertyFlags & properties) ==
+			    properties &&
+		    typeBits & (1 << i)) {
+			return i;
+		}
+	}
+	return 0xFFFFFFFF;
+}
+
+static void cmd_buf_begin(amf_texencode *enc)
+{
+	VkCommandBufferBeginInfo commandBufferBegin = {};
+	commandBufferBegin.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+	VK_CHECK(vkBeginCommandBuffer(enc->cmdbuf, &commandBufferBegin));
+}
+
+static void cmd_buf_submit(amf_texencode *enc, VkSemaphore *semaphore = nullptr,
+			   VkFence *fence = nullptr)
+{
+	VK_CHECK(vkEndCommandBuffer(enc->cmdbuf));
+	VkSubmitInfo submitInfo = {};
+	submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
+	submitInfo.commandBufferCount = 1;
+	submitInfo.pCommandBuffers = &enc->cmdbuf;
+	submitInfo.signalSemaphoreCount = semaphore ? 1 : 0;
+	submitInfo.pSignalSemaphores = semaphore;
+	if (fence) {
+		VK_CHECK(vkQueueSubmit(enc->queue, 1, &submitInfo, *fence));
+		return;
+	}
+	VkFenceCreateInfo fenceInfo = {};
+	fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+	VkFence f;
+	VK_CHECK(vkCreateFence(enc->vk->hDevice, &fenceInfo, nullptr, &f));
+	VK_CHECK(vkQueueSubmit(enc->queue, 1, &submitInfo, f));
+	VK_CHECK(vkWaitForFences(enc->vk->hDevice, 1, &f, VK_TRUE, UINT64_MAX));
+	vkDestroyFence(enc->vk->hDevice, f, nullptr);
+}
+
+static void add_output_tex(amf_texencode *enc, handle_tex &output_tex,
+			   encoder_texture *from)
+{
+	output_tex.surfaceVk = new AMFVulkanSurface;
+	output_tex.surfaceVk->cbSizeof = sizeof(AMFVulkanSurface);
+	output_tex.surfaceVk->pNext = nullptr;
+
+	VkImageCreateInfo imageInfo = {};
+	imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+	imageInfo.imageType = VK_IMAGE_TYPE_2D;
+	imageInfo.format = to_vk_format(enc->amf_format);
+	imageInfo.extent.width = from->info.width;
+	imageInfo.extent.height = from->info.height;
+	imageInfo.extent.depth = 1;
+	imageInfo.arrayLayers = 1;
+	imageInfo.mipLevels = 1;
+	imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+	imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+	imageInfo.tiling = VK_IMAGE_TILING_LINEAR;
+	imageInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT |
+			  VK_IMAGE_USAGE_TRANSFER_DST_BIT;
+	imageInfo.flags = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
+	imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+	VK_CHECK(vkCreateImage(enc->vk->hDevice, &imageInfo, nullptr,
+			       &output_tex.surfaceVk->hImage));
+
+	VkMemoryRequirements memoryReqs;
+	vkGetImageMemoryRequirements(enc->vk->hDevice,
+				     output_tex.surfaceVk->hImage, &memoryReqs);
+	VkMemoryAllocateInfo memoryAllocInfo = {};
+	memoryAllocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+	memoryAllocInfo.allocationSize = memoryReqs.size;
+	memoryAllocInfo.memoryTypeIndex =
+		memoryTypeIndex(enc, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
+				memoryReqs.memoryTypeBits);
+	VK_CHECK(vkAllocateMemory(enc->vk->hDevice, &memoryAllocInfo, nullptr,
+				  &output_tex.surfaceVk->hMemory));
+	VK_CHECK(vkBindImageMemory(enc->vk->hDevice,
+				   output_tex.surfaceVk->hImage,
+				   output_tex.surfaceVk->hMemory, 0));
+
+	cmd_buf_begin(enc);
+	VkImageMemoryBarrier imageBarrier = {};
+	imageBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+	imageBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+	imageBarrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;
+	imageBarrier.image = output_tex.surfaceVk->hImage;
+	imageBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+	imageBarrier.subresourceRange.layerCount = 1;
+	imageBarrier.subresourceRange.levelCount = 1;
+	imageBarrier.srcAccessMask = 0;
+	imageBarrier.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT |
+				     VK_ACCESS_MEMORY_WRITE_BIT;
+	vkCmdPipelineBarrier(enc->cmdbuf, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+			     VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0,
+			     nullptr, 1, &imageBarrier);
+	cmd_buf_submit(enc);
+
+	output_tex.surfaceVk->iSize = memoryAllocInfo.allocationSize;
+	output_tex.surfaceVk->eFormat = imageInfo.format;
+	output_tex.surfaceVk->iWidth = imageInfo.extent.width;
+	output_tex.surfaceVk->iHeight = imageInfo.extent.height;
+	output_tex.surfaceVk->eCurrentLayout = imageInfo.initialLayout;
+	output_tex.surfaceVk->eUsage = AMF_SURFACE_USAGE_DEFAULT;
+	output_tex.surfaceVk->eAccess = AMF_MEMORY_CPU_LOCAL;
+	output_tex.surfaceVk->Sync.cbSizeof = sizeof(AMFVulkanSync);
+	output_tex.surfaceVk->Sync.pNext = nullptr;
+	output_tex.surfaceVk->Sync.hSemaphore = nullptr;
+	output_tex.surfaceVk->Sync.bSubmitted = true;
+	output_tex.surfaceVk->Sync.hFence = nullptr;
+
+	enc->input_textures.push_back(output_tex);
+}
+
+static inline void create_gl_tex(amf_texencode *enc, gl_tex &output_tex,
+				 encoder_texture *from)
+{
+	if (output_tex.glsem)
+		return;
+
+	cmd_buf_begin(enc);
+	for (int i = 0; i < 2; ++i) {
+		obs_enter_graphics();
+		auto gs_format = gs_texture_get_color_format(from->tex[i]);
+		output_tex.planes[i].width = gs_texture_get_width(from->tex[i]);
+		output_tex.planes[i].height =
+			gs_texture_get_height(from->tex[i]);
+		obs_leave_graphics();
+
+		VkExternalMemoryImageCreateInfo extImageInfo = {};
+		extImageInfo.sType =
+			VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+		extImageInfo.handleTypes =
+			VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+
+		VkImageCreateInfo imageInfo = {};
+		imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+		imageInfo.pNext = &extImageInfo;
+		imageInfo.imageType = VK_IMAGE_TYPE_2D;
+		imageInfo.format = to_vk_format(gs_format);
+		imageInfo.extent.width = output_tex.planes[i].width;
+		imageInfo.extent.height = output_tex.planes[i].height;
+		imageInfo.extent.depth = 1;
+		imageInfo.arrayLayers = 1;
+		imageInfo.mipLevels = 1;
+		imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+		imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+		imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+		imageInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT |
+				  VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
+		imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+		VK_CHECK(vkCreateImage(enc->vk->hDevice, &imageInfo, nullptr,
+				       &output_tex.planes[i].image));
+
+		VkMemoryRequirements memoryReqs;
+		vkGetImageMemoryRequirements(enc->vk->hDevice,
+					     output_tex.planes[i].image,
+					     &memoryReqs);
+
+		VkExportMemoryAllocateInfo expMemoryAllocInfo = {};
+		expMemoryAllocInfo.sType =
+			VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
+		expMemoryAllocInfo.handleTypes =
+			VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+		VkMemoryDedicatedAllocateInfo dedMemoryAllocInfo = {};
+		dedMemoryAllocInfo.sType =
+			VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
+		dedMemoryAllocInfo.image = output_tex.planes[i].image;
+		dedMemoryAllocInfo.pNext = &expMemoryAllocInfo;
+
+		VkMemoryAllocateInfo memoryAllocInfo = {};
+		memoryAllocInfo.pNext = &dedMemoryAllocInfo;
+		memoryAllocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+		memoryAllocInfo.allocationSize = memoryReqs.size;
+		memoryAllocInfo.memoryTypeIndex = memoryTypeIndex(
+			enc, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
+			memoryReqs.memoryTypeBits);
+		VK_CHECK(vkAllocateMemory(enc->vk->hDevice, &memoryAllocInfo,
+					  nullptr,
+					  &output_tex.planes[i].memory));
+		VK_CHECK(vkBindImageMemory(enc->vk->hDevice,
+					   output_tex.planes[i].image,
+					   output_tex.planes[i].memory, 0));
+
+		VkImageMemoryBarrier imageBarrier = {};
+		imageBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+		imageBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+		imageBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+		imageBarrier.image = output_tex.planes[i].image;
+		imageBarrier.subresourceRange.aspectMask =
+			VK_IMAGE_ASPECT_COLOR_BIT;
+		imageBarrier.subresourceRange.layerCount = 1;
+		imageBarrier.subresourceRange.levelCount = 1;
+		imageBarrier.srcAccessMask = 0;
+		imageBarrier.dstAccessMask = 0;
+		vkCmdPipelineBarrier(enc->cmdbuf,
+				     VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+				     VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0,
+				     nullptr, 0, nullptr, 1, &imageBarrier);
+
+		imageBarrier.oldLayout = imageBarrier.newLayout;
+		imageBarrier.srcQueueFamilyIndex = 0;
+		imageBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
+		vkCmdPipelineBarrier(enc->cmdbuf,
+				     VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+				     VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0,
+				     nullptr, 0, nullptr, 1, &imageBarrier);
+
+		// Import memory
+		VkMemoryGetFdInfoKHR memFdInfo = {};
+		memFdInfo.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+		memFdInfo.memory = output_tex.planes[i].memory;
+		memFdInfo.handleType =
+			VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+		int fd = -1;
+		VK_CHECK(enc->vkGetMemoryFdKHR(enc->vk->hDevice, &memFdInfo,
+					       &fd));
+
+		obs_enter_graphics();
+
+		enc->glCreateMemoryObjectsEXT(1, &output_tex.planes[i].glmem);
+		GLint dedicated = GL_TRUE;
+		enc->glMemoryObjectParameterivEXT(
+			output_tex.planes[i].glmem,
+			GL_DEDICATED_MEMORY_OBJECT_EXT, &dedicated);
+		enc->glImportMemoryFdEXT(output_tex.planes[i].glmem,
+					 memoryAllocInfo.allocationSize,
+					 GL_HANDLE_TYPE_OPAQUE_FD_EXT, fd);
+
+		enc->glGenTextures(1, &output_tex.planes[i].gltex);
+		enc->glBindTexture(GL_TEXTURE_2D, output_tex.planes[i].gltex);
+		enc->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_TILING_EXT,
+				     GL_OPTIMAL_TILING_EXT);
+		enc->glTexStorageMem2DEXT(GL_TEXTURE_2D, 1,
+					  to_gl_format(gs_format),
+					  imageInfo.extent.width,
+					  imageInfo.extent.height,
+					  output_tex.planes[i].glmem, 0);
+
+		enc->glGenFramebuffers(1, &output_tex.planes[i].fbo);
+		enc->glBindFramebuffer(GL_FRAMEBUFFER,
+				       output_tex.planes[i].fbo);
+		enc->glFramebufferTexture2D(GL_FRAMEBUFFER,
+					    GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+					    output_tex.planes[i].gltex, 0);
+		enc->glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+		bool import_ok =
+			enc->glIsMemoryObjectEXT(output_tex.planes[i].glmem) &&
+			enc->glGetError() == GL_NO_ERROR;
+
+		obs_leave_graphics();
+
+		if (!import_ok)
+			throw "OpenGL texture import failed";
+	}
+
+	VkExportSemaphoreCreateInfo expSemInfo = {};
+	expSemInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+	expSemInfo.handleTypes =
+		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+	VkSemaphoreCreateInfo semInfo = {};
+	semInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+	semInfo.pNext = &expSemInfo;
+	VK_CHECK(vkCreateSemaphore(enc->vk->hDevice, &semInfo, nullptr,
+				   &output_tex.sem));
+
+	VK_CHECK(vkCreateSemaphore(enc->vk->hDevice, &semInfo, nullptr,
+				   &output_tex.copySem));
+
+	VkFenceCreateInfo fenceInfo = {};
+	fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+	VK_CHECK(vkCreateFence(enc->vk->hDevice, &fenceInfo, nullptr,
+			       &output_tex.copyFence));
+
+	cmd_buf_submit(enc, &output_tex.copySem, &output_tex.copyFence);
+
+	// Import semaphores
+	VkSemaphoreGetFdInfoKHR semFdInfo = {};
+	semFdInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+	semFdInfo.semaphore = output_tex.sem;
+	semFdInfo.handleType =
+		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+	int fd = -1;
+	VK_CHECK(enc->vkGetSemaphoreFdKHR(enc->vk->hDevice, &semFdInfo, &fd));
+
+	semFdInfo.semaphore = output_tex.copySem;
+	int fdCopy = -1;
+	VK_CHECK(enc->vkGetSemaphoreFdKHR(enc->vk->hDevice, &semFdInfo,
+					  &fdCopy));
+
+	obs_enter_graphics();
+
+	enc->glGenSemaphoresEXT(1, &output_tex.glsem);
+	enc->glGenSemaphoresEXT(1, &output_tex.glCopySem);
+	enc->glImportSemaphoreFdEXT(output_tex.glsem,
+				    GL_HANDLE_TYPE_OPAQUE_FD_EXT, fd);
+	enc->glImportSemaphoreFdEXT(output_tex.glCopySem,
+				    GL_HANDLE_TYPE_OPAQUE_FD_EXT, fdCopy);
+
+	bool import_ok = enc->glIsSemaphoreEXT(output_tex.glsem) &&
+			 enc->glIsSemaphoreEXT(output_tex.glCopySem) &&
+			 enc->glGetError() == GL_NO_ERROR;
+
+	obs_leave_graphics();
+
+	if (!import_ok)
+		throw "OpenGL semaphore import failed";
+}
+
+static inline bool get_available_tex(amf_texencode *enc, handle_tex &output_tex)
+{
+	std::scoped_lock lock(enc->textures_mutex);
+	if (enc->available_textures.size()) {
+		output_tex = enc->available_textures.back();
+		enc->available_textures.pop_back();
+		return true;
+	}
+
+	return false;
+}
+
+static inline void get_output_tex(amf_texencode *enc, handle_tex &output_tex,
+				  encoder_texture *from)
+{
+	if (!get_available_tex(enc, output_tex))
+		add_output_tex(enc, output_tex, from);
+
+	create_gl_tex(enc, enc->gltex, from);
+}
+
+static inline GLuint get_read_fbo(amf_texencode *enc, gs_texture *tex)
+{
+	auto it = enc->read_fbos.find(tex);
+	if (it != enc->read_fbos.end()) {
+		return it->second;
+	}
+	GLuint *tex_obj = static_cast<GLuint *>(gs_texture_get_obj(tex));
+	GLuint fbo;
+	enc->glGenFramebuffers(1, &fbo);
+	enc->glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+	enc->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+				    GL_TEXTURE_2D, *tex_obj, 0);
+	enc->read_fbos.insert({tex, fbo});
+	return fbo;
+}
+#endif
 
 static constexpr amf_int64 macroblock_size = 16;
 
@@ -513,7 +1236,7 @@ static void convert_to_encoder_packet(amf_base *enc, AMFDataPtr &data,
 	enc->packet_data = AMFBufferPtr(data);
 	data->GetProperty(L"PTS", &packet->pts);
 
-	const wchar_t *get_output_type;
+	const wchar_t *get_output_type = NULL;
 	switch (enc->codec) {
 	case amf_codec_type::AVC:
 		get_output_type = AMF_VIDEO_ENCODER_OUTPUT_DATA_TYPE;
@@ -623,6 +1346,8 @@ static void roi_cb(void *param, obs_encoder_roi *roi)
 
 static void create_roi(amf_base *enc, AMFSurface *amf_surf)
 {
+	amf_surf;
+
 	uint32_t mb_size = 16; /* H.264 is always 16x16 */
 	if (enc->codec == amf_codec_type::HEVC ||
 	    enc->codec == amf_codec_type::AV1)
@@ -746,6 +1471,7 @@ static void amf_encode_base(amf_base *enc, AMFSurface *amf_surf,
 static bool amf_encode_tex(void *data, uint32_t handle, int64_t pts,
 			   uint64_t lock_key, uint64_t *next_key,
 			   encoder_packet *packet, bool *received_packet)
+#ifdef _WIN32
 try {
 	amf_texencode *enc = (amf_texencode *)data;
 	ID3D11DeviceContext *context = enc->context;
@@ -822,6 +1548,209 @@ try {
 	*received_packet = false;
 	return false;
 }
+#else
+{
+	UNUSED_PARAMETER(data);
+	UNUSED_PARAMETER(handle);
+	UNUSED_PARAMETER(pts);
+	UNUSED_PARAMETER(lock_key);
+	UNUSED_PARAMETER(next_key);
+	UNUSED_PARAMETER(packet);
+	UNUSED_PARAMETER(received_packet);
+	return false;
+}
+#endif
+
+static bool amf_encode_tex2(void *data, encoder_texture *texture, int64_t pts,
+			    uint64_t lock_key, uint64_t *next_key,
+			    encoder_packet *packet, bool *received_packet)
+try {
+	UNUSED_PARAMETER(lock_key);
+	UNUSED_PARAMETER(next_key);
+
+	amf_texencode *enc = (amf_texencode *)data;
+	handle_tex output_tex;
+	AMFSurfacePtr amf_surf;
+	AMF_RESULT res;
+
+	if (!texture) {
+		throw "Encode failed: bad texture handle";
+	}
+
+	/* ------------------------------------ */
+	/* get an output tex                    */
+
+	get_output_tex(enc, output_tex, texture);
+
+	/* ------------------------------------ */
+	/* copy to output tex                   */
+
+	VK_CHECK(vkWaitForFences(enc->vk->hDevice, 1, &enc->gltex.copyFence,
+				 VK_TRUE, UINT64_MAX));
+	VK_CHECK(vkResetFences(enc->vk->hDevice, 1, &enc->gltex.copyFence));
+
+	obs_enter_graphics();
+
+	GLuint sem_tex[2];
+	GLenum sem_layout[2];
+	for (int i = 0; i < 2; ++i) {
+		sem_tex[i] = enc->gltex.planes[i].gltex;
+		sem_layout[i] = GL_LAYOUT_TRANSFER_SRC_EXT;
+	}
+	enc->glWaitSemaphoreEXT(enc->gltex.glCopySem, 0, 0, 2, sem_tex,
+				sem_layout);
+	for (int i = 0; i < 2; ++i) {
+		GLuint read_fbo = get_read_fbo(enc, texture->tex[i]);
+		enc->glBindFramebuffer(GL_READ_FRAMEBUFFER, read_fbo);
+		enc->glBindFramebuffer(GL_DRAW_FRAMEBUFFER,
+				       enc->gltex.planes[i].fbo);
+		enc->glBlitFramebuffer(0, 0, enc->gltex.planes[i].width,
+				       enc->gltex.planes[i].height, 0, 0,
+				       enc->gltex.planes[i].width,
+				       enc->gltex.planes[i].height,
+				       GL_COLOR_BUFFER_BIT, GL_NEAREST);
+		enc->glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+		enc->glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+	}
+	enc->glSignalSemaphoreEXT(enc->gltex.glsem, 0, 0, 2, sem_tex,
+				  sem_layout);
+
+	obs_leave_graphics();
+
+	res = enc->amf_context1->CreateSurfaceFromVulkanNative(
+		output_tex.surfaceVk, &amf_surf, enc);
+	if (res != AMF_OK)
+		throw amf_error("CreateSurfaceFromVulkanNative failed", res);
+
+	/* ------------------------------------ */
+	/* copy to submit tex                   */
+
+	VkCommandBufferBeginInfo commandBufferBegin = {};
+	commandBufferBegin.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+	VK_CHECK(vkBeginCommandBuffer(enc->cmdbuf, &commandBufferBegin));
+
+	VkImageMemoryBarrier imageBarriers[2];
+	imageBarriers[0] = {};
+	imageBarriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+	imageBarriers[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+	imageBarriers[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+	imageBarriers[0].image = enc->gltex.planes[0].image;
+	imageBarriers[0].subresourceRange.aspectMask =
+		VK_IMAGE_ASPECT_COLOR_BIT;
+	imageBarriers[0].subresourceRange.layerCount = 1;
+	imageBarriers[0].subresourceRange.levelCount = 1;
+	imageBarriers[0].srcAccessMask = 0;
+	imageBarriers[0].dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
+	imageBarriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
+	imageBarriers[0].dstQueueFamilyIndex = 0;
+	imageBarriers[1] = {};
+	imageBarriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+	imageBarriers[1].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+	imageBarriers[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+	imageBarriers[1].image = enc->gltex.planes[1].image;
+	imageBarriers[1].subresourceRange.aspectMask =
+		VK_IMAGE_ASPECT_COLOR_BIT;
+	imageBarriers[1].subresourceRange.layerCount = 1;
+	imageBarriers[1].subresourceRange.levelCount = 1;
+	imageBarriers[1].srcAccessMask = 0;
+	imageBarriers[1].dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
+	imageBarriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
+	imageBarriers[1].dstQueueFamilyIndex = 0;
+	vkCmdPipelineBarrier(enc->cmdbuf, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+			     VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0,
+			     nullptr, 2, imageBarriers);
+
+	VkImageCopy imageCopy = {};
+	imageCopy.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+	imageCopy.srcSubresource.mipLevel = 0;
+	imageCopy.srcSubresource.baseArrayLayer = 0;
+	imageCopy.srcSubresource.layerCount = 1;
+	imageCopy.srcOffset.x = 0;
+	imageCopy.srcOffset.y = 0;
+	imageCopy.srcOffset.z = 0;
+	imageCopy.dstSubresource.aspectMask = VK_IMAGE_ASPECT_PLANE_0_BIT;
+	imageCopy.dstSubresource.mipLevel = 0;
+	imageCopy.dstSubresource.baseArrayLayer = 0;
+	imageCopy.dstSubresource.layerCount = 1;
+	imageCopy.dstOffset.x = 0;
+	imageCopy.dstOffset.y = 0;
+	imageCopy.dstOffset.z = 0;
+	imageCopy.extent.width = enc->gltex.planes[0].width;
+	imageCopy.extent.height = enc->gltex.planes[0].height;
+	imageCopy.extent.depth = 1;
+	vkCmdCopyImage(enc->cmdbuf, enc->gltex.planes[0].image,
+		       VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+		       output_tex.surfaceVk->hImage, VK_IMAGE_LAYOUT_GENERAL, 1,
+		       &imageCopy);
+
+	imageCopy.dstSubresource.aspectMask = VK_IMAGE_ASPECT_PLANE_1_BIT;
+	imageCopy.extent.width = enc->gltex.planes[1].width;
+	imageCopy.extent.height = enc->gltex.planes[1].height;
+	vkCmdCopyImage(enc->cmdbuf, enc->gltex.planes[1].image,
+		       VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+		       output_tex.surfaceVk->hImage, VK_IMAGE_LAYOUT_GENERAL, 1,
+		       &imageCopy);
+
+	imageBarriers[0].srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
+	imageBarriers[0].dstAccessMask = 0;
+	imageBarriers[0].srcQueueFamilyIndex = 0;
+	imageBarriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
+	imageBarriers[1].srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
+	imageBarriers[1].dstAccessMask = 0;
+	imageBarriers[1].srcQueueFamilyIndex = 0;
+	imageBarriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
+	vkCmdPipelineBarrier(enc->cmdbuf, VK_PIPELINE_STAGE_TRANSFER_BIT,
+			     VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0,
+			     nullptr, 0, nullptr, 2, imageBarriers);
+
+	VK_CHECK(vkEndCommandBuffer(enc->cmdbuf));
+
+	VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
+	VkSubmitInfo submitInfo = {};
+	submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
+	submitInfo.commandBufferCount = 1;
+	submitInfo.pCommandBuffers = &enc->cmdbuf;
+	submitInfo.waitSemaphoreCount = 1;
+	submitInfo.pWaitSemaphores = &enc->gltex.sem;
+	submitInfo.pWaitDstStageMask = &waitStage;
+	submitInfo.signalSemaphoreCount = 1;
+	submitInfo.pSignalSemaphores = &enc->gltex.copySem;
+	VK_CHECK(vkQueueSubmit(enc->queue, 1, &submitInfo,
+			       enc->gltex.copyFence));
+
+	output_tex.surfaceVk->Sync.hSemaphore = enc->gltex.copySem;
+	output_tex.surfaceVk->Sync.bSubmitted = true;
+
+	int64_t last_ts = convert_to_amf_ts(enc, pts - 1);
+	int64_t cur_ts = convert_to_amf_ts(enc, pts);
+
+	amf_surf->SetPts(cur_ts);
+	amf_surf->SetProperty(L"PTS", pts);
+
+	{
+		std::scoped_lock lock(enc->textures_mutex);
+		enc->active_textures[amf_surf.GetPtr()] = output_tex;
+	}
+
+	/* ------------------------------------ */
+	/* do actual encode                     */
+
+	amf_encode_base(enc, amf_surf, packet, received_packet);
+	return true;
+
+} catch (const char *err) {
+	amf_texencode *enc = (amf_texencode *)data;
+	error("%s: %s", __FUNCTION__, err);
+	*received_packet = false;
+	return false;
+
+} catch (const amf_error &err) {
+	amf_texencode *enc = (amf_texencode *)data;
+	error("%s: %s: %ls", __FUNCTION__, err.str,
+	      amf_trace->GetResultText(err.res));
+	*received_packet = false;
+	return false;
+}
 
 static buf_t alloc_buf(amf_fallback *enc)
 {
@@ -1083,6 +2012,8 @@ try {
 	if (res != AMF_OK)
 		throw amf_error("CreateContext failed", res);
 
+	enc->amf_context1 = AMFContext1Ptr(enc->amf_context);
+
 	enc->init();
 
 	const wchar_t *codec = nullptr;
@@ -1287,6 +2218,7 @@ static const char *amf_avc_get_name(void *)
 
 static inline int get_avc_preset(amf_base *enc, const char *preset)
 {
+	UNUSED_PARAMETER(enc);
 	if (astrcmpi(preset, "quality") == 0)
 		return AMF_VIDEO_ENCODER_QUALITY_PRESET_QUALITY;
 	else if (astrcmpi(preset, "speed") == 0)
@@ -1409,7 +2341,7 @@ static bool amf_avc_init(void *data, obs_data_t *settings)
 		}
 
 	} else if (bf != 0) {
-		warn("B-Frames set to %lld but b-frames are not "
+		warn("B-Frames set to %" PRId64 " but b-frames are not "
 		     "supported by this device",
 		     bf);
 		bf = 0;
@@ -1454,12 +2386,12 @@ static bool amf_avc_init(void *data, obs_data_t *settings)
 
 	info("settings:\n"
 	     "\trate_control: %s\n"
-	     "\tbitrate:      %d\n"
-	     "\tcqp:          %d\n"
+	     "\tbitrate:      %" PRId64 "\n"
+	     "\tcqp:          %" PRId64 "\n"
 	     "\tkeyint:       %d\n"
 	     "\tpreset:       %s\n"
 	     "\tprofile:      %s\n"
-	     "\tb-frames:     %d\n"
+	     "\tb-frames:     %" PRId64 "\n"
 	     "\twidth:        %d\n"
 	     "\theight:       %d\n"
 	     "\tparams:       %s",
@@ -1539,8 +2471,10 @@ try {
 	enc->encoder = encoder;
 	enc->encoder_str = "texture-amf-h264";
 
+#ifdef _WIN32
 	if (!amf_init_d3d11(enc.get()))
 		throw "Failed to create D3D11";
+#endif
 
 	amf_avc_create_internal(enc.get(), settings);
 	return enc.release();
@@ -1615,6 +2549,7 @@ static void register_avc()
 	amf_encoder_info.destroy = amf_destroy;
 	amf_encoder_info.update = amf_avc_update;
 	amf_encoder_info.encode_texture = amf_encode_tex;
+	amf_encoder_info.encode_texture2 = amf_encode_tex2;
 	amf_encoder_info.get_defaults = amf_defaults;
 	amf_encoder_info.get_properties = amf_avc_properties;
 	amf_encoder_info.get_extra_data = amf_extra_data;
@@ -1629,6 +2564,7 @@ static void register_avc()
 				OBS_ENCODER_CAP_DYN_BITRATE |
 				OBS_ENCODER_CAP_ROI;
 	amf_encoder_info.encode_texture = nullptr;
+	amf_encoder_info.encode_texture2 = nullptr;
 	amf_encoder_info.create = amf_avc_create_fallback;
 	amf_encoder_info.encode = amf_encode_fallback;
 	amf_encoder_info.get_video_info = h264_video_info_fallback;
@@ -1648,6 +2584,7 @@ static const char *amf_hevc_get_name(void *)
 
 static inline int get_hevc_preset(amf_base *enc, const char *preset)
 {
+	UNUSED_PARAMETER(enc);
 	if (astrcmpi(preset, "balanced") == 0)
 		return AMF_VIDEO_ENCODER_HEVC_QUALITY_PRESET_BALANCED;
 	else if (astrcmpi(preset, "speed") == 0)
@@ -1771,8 +2708,8 @@ static bool amf_hevc_init(void *data, obs_data_t *settings)
 
 	info("settings:\n"
 	     "\trate_control: %s\n"
-	     "\tbitrate:      %d\n"
-	     "\tcqp:          %d\n"
+	     "\tbitrate:      %" PRId64 "\n"
+	     "\tcqp:          %" PRId64 "\n"
 	     "\tkeyint:       %d\n"
 	     "\tpreset:       %s\n"
 	     "\tprofile:      %s\n"
@@ -1900,8 +2837,10 @@ try {
 	enc->encoder = encoder;
 	enc->encoder_str = "texture-amf-h265";
 
+#ifdef _WIN32
 	if (!amf_init_d3d11(enc.get()))
 		throw "Failed to create D3D11";
+#endif
 
 	amf_hevc_create_internal(enc.get(), settings);
 	return enc.release();
@@ -1972,6 +2911,7 @@ static void register_hevc()
 	amf_encoder_info.destroy = amf_destroy;
 	amf_encoder_info.update = amf_hevc_update;
 	amf_encoder_info.encode_texture = amf_encode_tex;
+	amf_encoder_info.encode_texture2 = amf_encode_tex2;
 	amf_encoder_info.get_defaults = amf_defaults;
 	amf_encoder_info.get_properties = amf_hevc_properties;
 	amf_encoder_info.get_extra_data = amf_extra_data;
@@ -1986,6 +2926,7 @@ static void register_hevc()
 				OBS_ENCODER_CAP_DYN_BITRATE |
 				OBS_ENCODER_CAP_ROI;
 	amf_encoder_info.encode_texture = nullptr;
+	amf_encoder_info.encode_texture2 = nullptr;
 	amf_encoder_info.create = amf_hevc_create_fallback;
 	amf_encoder_info.encode = amf_encode_fallback;
 	amf_encoder_info.get_video_info = h265_video_info_fallback;
@@ -2005,6 +2946,7 @@ static const char *amf_av1_get_name(void *)
 
 static inline int get_av1_preset(amf_base *enc, const char *preset)
 {
+	UNUSED_PARAMETER(enc);
 	if (astrcmpi(preset, "highquality") == 0)
 		return AMF_VIDEO_ENCODER_AV1_QUALITY_PRESET_HIGH_QUALITY;
 	else if (astrcmpi(preset, "quality") == 0)
@@ -2143,8 +3085,8 @@ static bool amf_av1_init(void *data, obs_data_t *settings)
 
 	info("settings:\n"
 	     "\trate_control: %s\n"
-	     "\tbitrate:      %d\n"
-	     "\tcqp:          %d\n"
+	     "\tbitrate:      %" PRId64 "\n"
+	     "\tcqp:          %" PRId64 "\n"
 	     "\tkeyint:       %d\n"
 	     "\tpreset:       %s\n"
 	     "\tprofile:      %s\n"
@@ -2219,8 +3161,10 @@ try {
 	enc->encoder = encoder;
 	enc->encoder_str = "texture-amf-av1";
 
+#ifdef _WIN32
 	if (!amf_init_d3d11(enc.get()))
 		throw "Failed to create D3D11";
+#endif
 
 	amf_av1_create_internal(enc.get(), settings);
 	return enc.release();
@@ -2301,6 +3245,7 @@ static void register_av1()
 	amf_encoder_info.destroy = amf_destroy;
 	amf_encoder_info.update = amf_av1_update;
 	amf_encoder_info.encode_texture = amf_encode_tex;
+	amf_encoder_info.encode_texture2 = amf_encode_tex2;
 	amf_encoder_info.get_defaults = amf_av1_defaults;
 	amf_encoder_info.get_properties = amf_av1_properties;
 	amf_encoder_info.get_extra_data = amf_extra_data;
@@ -2315,6 +3260,7 @@ static void register_av1()
 				OBS_ENCODER_CAP_DYN_BITRATE |
 				OBS_ENCODER_CAP_ROI;
 	amf_encoder_info.encode_texture = nullptr;
+	amf_encoder_info.encode_texture2 = nullptr;
 	amf_encoder_info.create = amf_av1_create_fallback;
 	amf_encoder_info.encode = amf_encode_fallback;
 	amf_encoder_info.get_video_info = av1_video_info_fallback;
@@ -2333,9 +3279,16 @@ static bool enum_luids(void *param, uint32_t idx, uint64_t luid)
 	return true;
 }
 
+#ifdef _WIN32
+#define OBS_AMF_TEST "obs-amf-test.exe"
+#else
+#define OBS_AMF_TEST "obs-amf-test"
+#endif
+
 extern "C" void amf_load(void)
 try {
 	AMF_RESULT res;
+#ifdef _WIN32
 	HMODULE amf_module_test;
 
 	/* Check if the DLL is present before running the more expensive */
@@ -2345,18 +3298,26 @@ try {
 	if (!amf_module_test)
 		throw "No AMF library";
 	FreeLibrary(amf_module_test);
+#else
+	void *amf_module_test = os_dlopen(AMF_DLL_NAMEA);
+	if (!amf_module_test)
+		throw "No AMF library";
+	os_dlclose(amf_module_test);
+#endif
 
 	/* ----------------------------------- */
 	/* Check for supported codecs          */
 
-	BPtr<char> test_exe = os_get_executable_path_ptr("obs-amf-test.exe");
+	BPtr<char> test_exe = os_get_executable_path_ptr(OBS_AMF_TEST);
 	std::stringstream cmd;
 	std::string caps_str;
 
 	cmd << '"';
 	cmd << test_exe;
 	cmd << '"';
+#ifdef _WIN32
 	enum_graphics_device_luids(enum_luids, &cmd);
+#endif
 
 	os_process_pipe_t *pp = os_process_pipe_create(cmd.str().c_str(), "r");
 	if (!pp)
@@ -2416,12 +3377,12 @@ try {
 	/* ----------------------------------- */
 	/* Init AMF                            */
 
-	amf_module = LoadLibraryW(AMF_DLL_NAME);
+	amf_module = os_dlopen(AMF_DLL_NAMEA);
 	if (!amf_module)
 		throw "AMF library failed to load";
 
 	AMFInit_Fn init =
-		(AMFInit_Fn)GetProcAddress(amf_module, AMF_INIT_FUNCTION_NAME);
+		(AMFInit_Fn)os_dlsym(amf_module, AMF_INIT_FUNCTION_NAME);
 	if (!init)
 		throw "Failed to get AMFInit address";
 
@@ -2433,7 +3394,7 @@ try {
 	if (res != AMF_OK)
 		throw amf_error("GetTrace failed", res);
 
-	AMFQueryVersion_Fn get_ver = (AMFQueryVersion_Fn)GetProcAddress(
+	AMFQueryVersion_Fn get_ver = (AMFQueryVersion_Fn)os_dlsym(
 		amf_module, AMF_QUERY_VERSION_FUNCTION_NAME);
 	if (!get_ver)
 		throw "Failed to get AMFQueryVersion address";
@@ -2472,7 +3433,7 @@ try {
 } catch (const amf_error &err) {
 	/* doing an error here because it means at least the library has loaded
 	 * successfully, so they probably have AMD at this point */
-	blog(LOG_ERROR, "%s: %s: 0x%lX", __FUNCTION__, err.str,
+	blog(LOG_ERROR, "%s: %s: 0x%uX", __FUNCTION__, err.str,
 	     (uint32_t)err.res);
 }
 
-- 
2.44.0

